sequenceDiagram
  participant MC-server as MC (server)
  participant Auth as Auth Service (/auth)
  participant Portal-BE as Portal Backend
  participant Iframe as Portal Iframe (browser)
  participant API as Protected API

  MC-server->>Auth: POST /auth (client_id+secret) -> {access, refresh}
  MC-server->>Portal-BE: POST /portal/ingest-token (refresh_token) (mTLS/HMAC)
  Portal-BE->>Auth: OPTIONAL validate or exchange refresh_token
  Portal-BE-->>MC-server: 200 OK (MC discards refresh_token)
  Portal-BE->>Portal-BE: store refresh_token encrypted (DB/HSM)
  Iframe->>Portal-BE: request page/session
  Portal-BE->>Iframe: set HttpOnly, Secure session cookie (or short-lived access token)
  Iframe->>Portal-BE: API request (cookie/session forwarded)
  Portal-BE->>Auth: refresh (when access expired) using stored refresh_token
  Portal-BE->>API: call protected API with access_token
  API-->>Portal-BE: respond
  Portal-BE-->>Iframe: respond to browser




sequenceDiagram
  participant MC as MC (Integrator - Browser/Client)
  participant Auth as Auth Service (/auth)
  participant PortalIframe as Portal Iframe (runs in browser)
  participant PortalBE as Portal Backend
  participant API as Protected API

  MC->>Auth: POST /auth (host-id + secret) -> { access_token, refresh_token }
  MC->>PortalIframe: open iframe + pass tokens (postMessage / URL / JS)
  PortalIframe->>PortalBE: set HttpOnly cookie (backend call or cookie set)
  PortalBE->>Auth: use stored refresh_token (but PortalBE may not have it if only iframe had it)
  PortalBE->>API: call protected API with access_token
  API-->>PortalBE: response
  PortalBE-->>PortalIframe: respond




sequenceDiagram
  %% Actors
  participant MC as MC (Integrator - Browser)
  participant Auth as Auth Service (/auth)
  participant Iframe as Portal Iframe (browser)
  participant PortalBE as Portal Backend
  participant API as Protected API

  %% Normal auth step (context)
  MC->>Auth: POST /auth (host-id + secret)\n{ access_token, refresh_token }

  %% PROBLEM 1: refresh_token lives in browser
  rect rgb(255,220,220)
    note right of MC
      ⚠️ PROBLEM 1:
      Refresh token (long-lived) now resides in the browser.
      Browsers are exposed (XSS, extensions, logs).
    end note
  end

  %% Token handoff (problem area)
  MC->>Iframe: open iframe + pass tokens\n(via postMessage / URL / JS)
  rect rgb(255,200,200)
    note right of Iframe
      ⚠️ PROBLEM 2:
      Token handoff through browser context.
      postMessage/URL/JS can leak tokens to logs, referers, or malicious scripts.
    end note
  end

  %% Iframe sets cookie (appears safe but weak link)
  Iframe->>PortalBE: request set-cookie / backend call
  PortalBE-->>Iframe: Set-Cookie: refresh=...; HttpOnly; Secure
  rect rgb(255,230,200)
    note right of PortalBE
      ⚠️ PROBLEM 3:
      Even if stored HttpOnly, the refresh token already passed through the browser.
      The initial exposure cannot be undone.
    end note
  end

  %% Rest of flow (not highlighted)
  PortalBE->>Auth: use stored/received refresh_token to refresh access_token
  PortalBE->>API: call Protected API with access_token
  API-->>PortalBE: response
  PortalBE-->>Iframe: respond to browser iframe
